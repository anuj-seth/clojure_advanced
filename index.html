<!doctype html>
<html lang="en">

	  <head>
		    <meta charset="utf-8">

		    <title>Clojure - made with secret alien technology</title>

		    <meta name="description" content="Slides for the functional thinking with clojure training">
		    <meta name="author" content="Anuj Seth">

		    <meta name="apple-mobile-web-app-capable" content="yes">
		    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		    <link rel="stylesheet" href="reveal.js/css/reveal.css">
		    <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
		    <!-- link rel="stylesheet" href="custom.css"-->

		    <!-- Code syntax highlighting -->
		    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		    <!-- Printing and PDF exports -->
		    <!-- script>
			   var link = document.createElement( 'link' );
			   link.rel = 'stylesheet';
			   link.type = 'text/css';
			   link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			   document.getElementsByTagName( 'head' )[0].appendChild( link );
		    </script-->

		    <!--[if lt IE 9]>
		        <script src="lib/js/html5shiv.js"></script>
		    <![endif]-->
	  </head>

	  <body>

		    <div class="reveal">

			      <!-- Any section element inside of this container is displayed as a slide -->
			      <div class="slides">
				        <section>
					          <h1>Clojure</h1>
					          <p>
                        <img src="resources/images/alien_technology.png">
					              <br><small>Trainer <a>Anuj Seth</a> </small></br>
					          </p>
				        </section>

                <section>
                    <h2>Regular Expressions</h2>
				        </section>

                <section>
	                  <blockquote>
	                      Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.<br>â€” Jamie Zawinski
	                  </blockquote>
	              </section>

                <section>
                    <p>Strings with a hash in the front are regular expressions - #"regex"</p>
                    <p>Clojure regexes produce java.util.regex.Pattern objects</p>
                    <p>Clojure uses the same regex syntax as java.util.regex.Pattern</p>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; re-matches matches the whole string
                    (re-matches #"abc" "abcabc")
                    ;=> nil

                    (re-matches #"abc.*" "abcabc")
                    ;=> "abcabc"

                    ;; if the regex has groups then we get
                    ;; a vector whose first element is the full match
                    ;; and rest are the matching groups
                    (re-matches #"abc(.*)" "abcabc")
                    ;=> ["abcabc" "abc"]
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if the regex has groups then we get
                    ;; a vector whose first element is the full match
                    ;; and rest are the matching groups
                    (re-matches #"abc(\d+)\|(\w*)" "abc123|def")
                    ;=> ["abc123|def" "123" "def"]

                    ;; re-matches can return three types of values
                    ;; nil, a string or a vector
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; let's make some test cases pass
                    ;; open the file regex_test.clj
                    ;; and make the first test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; re-find returns the first match within a string
                    (re-find #"\d{3}" "abc123abc456")
                    ;=> "123"

                    ;; with groups we get a vector
                    ;; just like re-matches
                    ;; you can match exact number of characters
                    ;; with {n}
                    ;; at least n not more than m with {n,m}
                    (re-find #"(\d{3})\w+(\d{3})" "abc123abc456")
                    ;=> ["123abc456" "123" "456"]
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file regex_test.clj
                    ;; and make the second test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; re-seq can be used to get all the matches
                    (re-seq #"\d" "abc123abc456")
                    ;=> ("1" "2" "3" "4" "5" "6")

                    ;; open the file regex_test.clj
                    ;; and make the third test case pass
                    ```
                </section>

                <section>
                    <pre><code data-trim>
                    ;; replace can be used to replace patterns in a string
                    (clojure.string/replace "John, Paul, George, Stuart"
                                            #"Stuart"
                                            "Ringo")
                    ;=> "John, Paul, George, Ringo"

                    ;; we can replace groups
                    (clojure.string/replace "+919887652314"
                                            #"(^\+)"
                                            "00")
                    ;=> "00919887652314"
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; we can give a function that provides the replacement
                    ;; let's see how that works in the next test case
                    ;; in regex_test.clj
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; we can split strings on a regex
                    (clojure.string/split "+91-9876-65438" #"-")
                    ;=> ["+91" "9876" "65438"]
                    ```
                </section>

				        <section>
                    <h2>Exceptions</h2>
				        </section>

                <section>
                    <pre><code data-trim>
                    (try
                        (/ 1 0)
                        (catch Exception e (str "caught exception: "
                                                (.getMessage e))))
                    ;=> "caught exception: Divide by zero"
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim>
                    ;; the accepted wisdom these days is to use ex-info
                    (try
                        (throw (ex-info "thrown exception: "
                                        {:msg "this is an exception"}))
                        (catch Exception e (ex-data e)))
                    ;=> {:msg "this is an exception"}

                    ;; you can print the ex-info object to get the
                    ;; full stack trace
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim>
                    ;; the message can be retrieved like this
                    (try
                        (throw (ex-info "thrown exception: "
                                        {:msg "this is an exception"}))
                        (catch Exception e (.getMessage e)))
                    ;=> "thrown exception: "

                    ;; the message is added to satisfy the base Throwable
                    ;; that has a detailMessage field in it
                    </code></pre>
                </section>

                <section>
                    <h2>Exceptions</h2>
                    <p>Don't use them</p>
                    <p>What follows is my opinion</p>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; open the file error_handling_test.clj
                    ;; to see what I mean

                    ;; and of course make the test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; a concern that you may have in the previous example:
                    ;; ok-or-never gets called even after one of the functions
                    ;; returns :error

                    ;; reduced to the rescue
                    ;; a slightly convoluted example
                    (reduce (fn [acc idx]
                              (if (= idx 26)
                                (reduced acc)
                                (assoc acc
                                       (char (+ 65 idx)) 
                                       (inc idx))))
                            {}
                            (range))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file error_handling_test_short_circuit.clj
                    ;; to see if you can use reduced

                    ;; and of course make the test case pass
                    ```
                </section>

				        <section>
                    <h2>Polymorphism and Types</h2>
				        </section>

				        <section>
                    <h2>Multimethods</h2>
				        </section>

                <section>
                    <p>Clojure supports runtime polymorphism through multimethods</p>
                    <p>Multimethods provide dispatch on an arbitrary function</p>
                    <p>Contrast this with OO polymorphism which dispatches on type of one variable</p>
				        </section>

                <section data-markdown>
                    ```clj
                    (defmulti data-handler :status)
                    (defmethod data-handler :error
                      [m]
                      (println "we have an error"))
                    (defmethod data-handler :ok
                      [m]
                      (println "we have good data"))
                    (defmethod data-handler :default
                      [m]
                      (println "we don't know what we have"))

                    (data-handler {:status :error})
                    ;=> we have an error
                    (data-handler {})
                    ;=> we don't know what we have
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file tree_walk_test.clj
                    ;; write a multimethod to evaluate the tree nodes
                    ;; and make the test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; did you notice that all our binary operators
                    ;; had the same code.

                    ;; hierarchies allow us to define relationships
                    ;; most commonly between keywords
                    (derive ::superman ::superhero)
                    (derive ::wonder-woman ::superhero)
                    (derive ::lex-luthor ::supervillain)

                    ;; what do the :: tell you ?
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; isa? can be used to query the hierarchy

                    (isa? ::superman ::superhero)
                    ;=> true
                    (isa? ::superman ::supervillain)
                    ;=> false
                    (isa? ::lex-luthor ::supervillain)
                    ;=> true
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (defmulti evil? :name)

                    (defmethod evil? ::superhero [_] :never)

                    (defmethod evil? ::lex-luthor [_] :always)

                    (evil? {:name ::superman})
                    ;; :never
                    (evil? {:name ::lex-luthor})
                    ;; :always
                    ```
	              </section>

                <section data-markdown>
                    ```clj
                    (derive ::batman ::superhero)
                    (defmethod evil? ::batman [_] :only-when-ends-justify-means)

                    (evil? {:name ::batman})
                    ```
	              </section>

                <section data-markdown>
                    ```clj
                    ;; open the file hierarchical_tree_walk_test.clj
                    ;; complete the multimethod definition
                    ;; and make the test case pass
                    ```
                </section>

                <section>
                    <h2>Protocols and Types</h2>
				        </section>

                <section>
                    <p>Protocols allow polymorphism on the type of the first argument</p>
                    <p>They are very fast</p>
                    <p>Don't worry if you have never used them</p>
				        </section>

                <section>
                    <p>Protocols provide a solution to the expression problem</p>
                    <p>What is the expression problem ?</p>
                    <p>Extend preexisting types to new methods</p>
                    <p>Extend preexisting methods to new types</p>
                    <p>Without touching existing code</p>
                </section>

                <section>
                    <font size="6">
                    <ul>
                        <li>OO makes it easy for new types to extend existing interfaces</li>
                        <ul>
                            <li>ArrayList, LinkedList, Stack all implement same interface</li>
                            <li>You can add a new type easily</li>
                        </ul>
                        <li>Functional languages make it easy to add functions over existing types</li>
                        <ul>
                            <li>conj, nth, count work with list, vector, map</li>
                            <li>You can add new functions supporting all types</li>
                        </ul>
                    </ul>
                    </font>
                </section>

                <section data-markdown>
                    ```clj
                    ;; what are protocols ?
                    ;; we want to encrypt our data
                    (defprotocol Encryptable
                      (encrypt [this] "Encrypt the given object"))

                    (extend-type java.lang.String
                      Encryptable
                      (encrypt [this] (apply str (reverse this))))

                    (encrypt "a string")
                    ;;=> "gnirts a"
                    ;; how about extending a hash map to be Encryptable ?
                    ;; Encrypt by converting to a string and encrypting that.
                    ;; what is the type of a hash-map ?
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (extend-type clojure.lang.PersistentArrayMap
                      Encryptable
                      (encrypt [this] (encrypt (str this))))

                    (encrypt {})
                    ;;=> "}{"
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if you want to provide implementations of
                    ;; multiple types at the same time
                    (extend-protocol Encryptable
                      java.lang.String
                      (encrypt [this] (apply str (reverse this)))
                      clojure.lang.PersistentArrayMap
                      (encrypt [this] (encrypt (str this))))
                    ```
                </section>

				        <section>
                    <h2>Records</h2>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; records are structured data types
                    ;; and along with deftype provide a way to
                    ;; implement abstractions defined by protocols
                    (defrecord Airport [icao iata])

                    ;; they come with 2 factory functions
                    (->Airport "ZBAA" "PEK")

                    (map->Airport {:icao "ZBAA"
                                   :iata "PEK"})
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; and for most purposes act like maps
                    (:iata (map->Airport {:icao "ZBAA"}))

                    (:icao (map->Airport {:icao "ZBAA"}))

                    ;; except that you cannot use them in the
                    ;; function place
                    ;; but we will fix that soon for our records
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if you dissoc a field what happens.
                    (dissoc (->Airport "ZBAA" "PEK") :icao)
                    ;; is it still an Airport ?

                    ;; you can also assoc extra keys to it
                    (assoc (->Airport "ZBAA" "PEK") :city "Beijing")
                    ;; is it still an Airport ?
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#place-protocol'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; can you create a record called City
                    ;; with 2 fields - name and country
                    ;; implementing the Place protocol
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#city'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#usage'></code></pre>
                </section>


                <section data-markdown>
                    ```clj
                    ;; let's say six months from now I have the
                    ;; requirement to add a function - is-in
                    ;; that reports the location of the place.
                    ;; we could modify the original Place protocol
                    ;; or extend our types to implement a new protocol
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#is-in'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#is-in-usage'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; how can I make my Airport record a callable function ?
                    ;; implement the clojure.lang.IFn interface methods
                    ;; (invoke [this k] ....)
                    ;; (invoke [this k not-found] ....)

                    ;; for completeness we should also implement applyTo
                    ;; or maybe not
                    ;; did anyone ever use apply with a hash map ?
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#callable-records-short'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#callable-records'></code></pre>
                </section>

                <section>
	                  <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Concurrency and parallelism are two related but different things</li>
                        <li>Concurrency is managing multiple tasks</li>
                        <li>Concurrency might be implemented by switching between multiple tasks running on one processor</li>
                        <li>Parallelism is a subset of concurrency and entails executing multiple tasks at the same time</li>
                    </ul>
                </section>


                <!-- section data-markdown>
                    ```clj
                    ; let's first take look at some functions that can 
                    ; parallelize your code without requiring any code changes

                    ; pvalues returns a lazy sequence of values of the expressions
                    ; evaluated in parallel
                    (defn sleeper 
                    [s thing] 
                    (Thread/sleep (* 1000 s))
                    thing)

                    (defn pvs 
                    [] 
                    (pvalues
                    (sleeper 2 :1st)
                    (sleeper 30 :2nd)
                    (keyword "3rd")))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's see how much time it takes to get the first
                    ; value
                    (time (first (pvs)))

                    ;=> "Elapsed time: 2003.992906 msecs"
                    ;=> :1st

                    ; the time taken for the first element is equal to
                    ; the time taken to realize that value
                    ; but we will see that the time taken to realize subsequent
                    ; values is as much as the most expensive element before it.
                    (time (last (pvs)))

                    ;=> "Elapsed time: 30007.241914 msecs"
                    ;=> :3rd
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; the reason for this is that clojure maintains a sliding window
                    ; within which all elements are realized and the total time taken
                    ; is that for the most expensive computation

                    ; generally, the sliding window is of size N + 2, where N is 
                    ; the number of cores
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; the pmap function is the parallel version of the map function
                    ; that we have already seen.
                    ; note the doall to realize the lazy seq
                    (time 
                    (doall
                    (pmap (comp inc (partial sleeper 2)) 
                    [1 2 3])))

                    ;=> Elapsed time: 1992.638618 msecs
                    ;=> (2 3 4)

                    ; the total cost of realizing the sequence is again bound
                    ; by the most expensive operation

                    ; pmap seems to work very well for the above example,
                    ; so should we replace all calls to map with pmap ?
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's do an experiment
                    ; define a range of 10 million numbers
                    ; pmap and map over it using a function
                    ; that multiplies each number by itself

                    ; don't forget to use doall

                    ; what is the time taken by pmap ?
                    ; by map ?
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    (def l (range 10000000))

                    (time (def a (doall (pmap #(* % %) l))))
                    ;=> "Elapsed time: 35843.501162 msecs"

                    (time (def a (doall (map #(* % %) l))))
                    ;=> "Elapsed time: 7848.107447 msecs"
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; whether we should or not replace map with pmap depends
                    ; on the use case.
                    ; there is some overhead associated with sending work off to
                    ; threads, co-ordinating result gathering in proper order.
                    ; if you are sure that your function cost is higher than this 
                    ; overhead then use pmap.

                    ; as with all parallel systems, you have to experiment and see what
                    ; works for your use case. 

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; finally there's the pcalls function which takes an arbitrary 
                    ; number of no argument functions and executes them in parallel
                    (time (doall 
                    (pcalls
                    #(sleeper 2 :first)
                    #(sleeper 3 :second)
                    #(keyword "3rd"))))

                    ;=> "Elapsed time: 3003.252293 msecs"
                    ;=> (:first :second :3rd)            

                    ; pcalls has the same benefits and trade-offs as pvalues and pmap
                    ```
                </section-->

                <section data-markdown>
                    ```clj
                    ; open the file palindrome_detector_test.clj
                    ; and make the test cases pass
                    ```
                </section>
                <section>
                    <pre><code data-sample="code/files/palindrome_detector_test.clj#4-25">
                    </code></pre>
                </section>

                <!-- section>
	                  <h3>Concurrency and Parallelism</h3>
                    <p>Let's get back to our discussion of concurrency by looking at</p>
                    <ul>
                        <li>Futures</li>
                        <li>Delays</li>
                        <li>Promises</li>
                    </ul>
                </section-->


                <!-- section>
	                  <h3>Concurrency and Parallelism</h3>
                    <p>Futures, delays and promises allow us to write concurrent code by decoupling</p>
                    <ul>
                        <li>Task definition</li>
                        <li>Task execution</li>
                        <li>Requiring the task's result</li>
                    </ul>
                </section-->

                <!-- section>
                    <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Our serial code consists of task definitions like <br>(web-api/get-customer 1234)</br></li>
                        <li>As soon as clojure encouters this it executes the task and blocks until the result of the API is available</li>
                        <li>Now let's see how futures, delays and promises let us break this flow</li>
                    </ul>
                </section-->


                <!-- section data-markdown>
                    ```clj
                    ; using futures you can define a task and place it on another
                    ; thread without requiring the result immediately.
                    (future (Thread/sleep 10000)
                    (println "this will print after 10 seconds"))

                    ; notice how the repl can continue executing other tasks
                    ; while the future executes in another thread.

                    ; you can fire off a future and forget about it
                    ; but most likely you are interested in it's result
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; if you noticed when we ran the future we got a funny
                    ; output on the repl immediately.
                    ; a future returns a reference that we can use to query it.

                    ; we can deref a future to get it's value 
                    (let [result (future (println "this will print only once")
                    (+ 1 1))]
                    (println "deref: " (deref result))
                    (println "@: " @result))

                    ; notice that @ is shorthand for deref and dereferencing 
                    ; the future twice executes it only once
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; you can also call realized? on a future to see if it 
                    ; is done running
                    (realized? (future (Thread/sleep 1000)))
                    ; => false

                    (let [f (future)]
                    @f
                    (realized? f))
                    ;=> true

                    ; we can also supply a timeout while dereferncing futures
                    (deref (future (Thread/sleep 1000) 0) 10 5)

                    ; one use case for futures could be to send stuff off to a logging
                    ; function to be executed in another thread
                    ```
                </section-->

                <!--section data-markdown>
                    ```clj
                    ; delays allow you to define a task without
                    ; having to execute it immediately or requiring the
                    ; result
                    (def a-simple-delay
                    (delay (let [message "the message from delay"]
                    (println "First deref:" message)
                    message))) 

                    ; we can start the execution of a delay by using force or @.
                    ; just like futures a delay is executed only once and 
                    ; it's value cached.
                    (force a-simple-delay)

                    ; notice how the first time 2 messages are printed
                    ; and subsequently only the value of the delay is returned
                    @a-simple-delay
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; one use case for delays could be to fire off a function
                    ; to be executed when the first out of multiple futures finishes
                    (let [notify (delay (send-email "blah@gmail.com"))]
                    (doseq [idx (range 10)]
                    (future (do-some-long-work idx)
                    (force notify))))  

                    ; note that even though (force notify) will be executed multiple
                    ; times from different threads the delay body only gets executed once.

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; promises are placeholders for values that can be delivered
                    ; by executing threads later on.
                    ; promises 
                    (def x (promise))
                    (def y (promise))
                    (def z (promise))

                    (future (deliver z (+ @x @y)))

                    (future (Thread/sleep 2000) (deliver x 42))

                    (future (Thread/sleep 2000) (deliver y 42))

                    @z
                    ;=> 84

                    ; promises block if we try to derefernce them before
                    ; a value has been delivered.
                    ; calling deliver multiple times has no effect
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's try to see how we can use promises

                    ; we want to fire off a number of tasks but we are only
                    ; interested in a logically true return value
                    (let [my-result (promise)]
                    (doseq [idx (range 10)]
                    (future (if-let [answer (some-function idx)]
                    (deliver my-result answer))))
                    (println "and the answer is: " @my-result))

                    ; note that even though deliver might be called multiple times 
                    ; only the first one has any effect

                    ; also we can provide a time out for the deref
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; another use case for promises is as a callback
                    ; i.e. to execute some piece of code once some 
                    ; other code finishes
                    (let [the-promise (promise)]
                    (future (println "the promised value is:" @the-promise))
                    (Thread/sleep 10000)
                    (deliver the-promise 42))

                    ; here the future will start running immediately but 
                    ; then block waiting for the promise
                    ```
                </section-->


                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; for in clojure acts like a list comprehension

                    ; let's say i have 2 collections and i want to
                    ; multiply each element of first collection with
                    ; each element of second
                    (def s1 [1 2 3 4 5])
                    (def s2 [1 2 3 4 5])

                    (for [x s1 y s2] (* x y))
                    ;=> (1 2 3 4 5 2 4 6 8 10 3 6 9 12 15 4 8 12 16 20 5 10 15 20 25)

                    ; notice that the right most collection is iterated fastest.

                    ; try writing the above using map

                    ```
                </section-->

                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; here's what i came up with

                    (mapcat #(map (partial * %) s2) s1)

                    ```
                </section-->

                <!-- section data-markdown>
                    Side Note
                    List comprehension
                    -------------------
                    ```clj
                    ; for supports modifiers let, when and while
                    (for [x [0 1 2 3 4 5]
                    :let [y (* x 3)]
                    :when (even? y)]
                    y)

                    ;=> (0 6 12)

                    (for [x [0 1 2 3 4 5]
                    :let [y (* x 3)]
                    :while (even? y)]
                    y)
                    ;=> (0)

                    ; while stops at the first element that evaluates
                    ; to false

                    ; can you figure out the output of this ?
                    (for [x [0  2  4 5]
                    :let [y (* x 3)]
                    :while (even? y)]
                    y)
                    ```
                </section-->

                <!-- section>
                    <h3>Concurrency and State</h3>
                    <ul>
                        <li>Java and other imperative languages manage shared state concurrency by using locks</li>
                        <li>These locks and mutexes protect access to shared data</li>
                        <li>Let's talk about how Clojure manages mutating state and concurrency</li>
                        <li>But I said clojure has immutable data structures !!!</li>
                    </ul>
                </section-->

                <!-- section>
                    <h3>Concurrency and State</h3>
                    <p>We will take a look at the following clojure reference types</p>
                    <ul>
                        <li>Atoms</li>
                        <li>Refs</li>
                        <li>Agents</li>
                    </ul>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; atom is a reference type used to store values
                    ; and atomically update them when required.
                    ; atoms are thread safe and can be used across threads
                    ; as light weight shared data.

                    (def counter (atom 0)) 

                    ; we can use the familiar deref operators to get the
                    ; atom's value
                    @counter
                    (deref counter)

                    ; note that blocking on dereference does not make sense in
                    ; case of atoms. it will always return the atom's current value
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; to update an atom to a new state we use swap!
                    (swap! counter inc)

                    ; dereferencing the atom after a swap! will show 
                    ; the new value
                    @counter
                    ;=> 1

                    ; note that swap! works synchronously so your thread
                    ; will block until the update function returns

                    ; we can also supply a function with multiple arguments
                    (swap! counter * 2 3)

                    ; this gets translated to (update-fn current-value args)

                    ; if you just want to update state without caring about
                    ; previous value you can just use reset!
                    (reset! counter -1)
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; what happens if two threads call swap! on the same
                    ; atom ? can we lose one of those updates ?
                    ; the answer is no since atoms follow compare and set
                    ; semantics.
                    ; what this means is that atoms
                    ; 1. read current state of the atom
                    ; 2. apply update function
                    ; 3. recheck that atom's current value is same as step 1
                    ; 4. if yes, then update atom to new state
                    ; 5. else go through the process again
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; make the below test cases pass
                    (def counter (atom 0))

                    (= __ @counter)

                    (= __ (do (swap! counter inc)
                    @counter))

                    (= 5 (do __
                    @counter))

                    (= __ (do (swap! counter + 1 2 3 4 5)
                    @counter))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; refs are another reference type that allow you
                    ; to update the state of multiple entities using
                    ; transaction semantics
                    (def account-a (ref {:name "a" :balance 1000}))
                    (def account-b (ref {:name "b" :balance 200000}))

                    ; we can deref refs to get their value
                    (:balance @account-a)

                    ; now we want to transfer some money from account-b to a
                    ; but we want this done as a transaction just like in databases
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; we use alter to  modify refs within a transaction started
                    ; by dosync
                    ; calling alter without an enclosing transaction causes
                    ; an error

                    (dosync
                    (alter account-a update-in [:balance] + 1000)
                    (alter account-b update-in [:balance] - 1000))

                    ; if we now check the values of the refs we see
                    @account-a
                    ;=> {:name "a", :balance 2000}

                    @account-b
                    ;=> {:name "b", :balance 199000} 
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; transactions on refs support the ACI properties, 
                    ; subset of ACID in databases

                    ; they are atomic i.e. all refs are updated or none
                    ; they are consistent, meaning refs will always have valid states
                    ; they are isolated i.e. transactions act as if executed serially

                    ; if two threads run simultaneous transactions, 
                    ; one of them will retry 
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; finally ref-set can be used to update the value of
                    ; any ref

                    (dosync
                    (ref-set account-a {:name "a" :balance 0}))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; make the below test cases pass

                    (def the-world (ref "hello"))

                    (= __ (do (dosync (ref-set the-world "better"))
                    @the-world))

                    (= __ (let [exclamator (fn [x] (str x "!"))]
                    (dosync (alter the-world exclamator)
                    (alter the-world exclamator)
                    (alter the-world exclamator))
                    @the-world))

                    (= 0 (do __
                    @the-world))
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; agents are a reference type that have a queue holding
                    ; the actions that need to be performed on the agent's value

                    (def simple-agent (agent []))

                    ; we can enqueue an action for the agent by using send
                    ; or send-off

                    (send simple-agent conj "abcd")

                    @simple-agent
                    ;=> ["abcd"]

                    ; send returns immediately with the value of the agent 
                    ; the update on the agent happens in a thread on thread pool
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; what about send-off ?
                    ; send works with the fixed thread pool and 
                    ; hence if all your threads are busy your agent may freeze

                    ; send-off potentially spawns a new thread and executes the
                    ; function  

                    ; this means that send-off may be a bit slower but you should 
                    ; use it for long running/blocking tasks so as not to block all
                    ; threads of the fixed thread pool
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; there are other ways of getting concurrency or writing
                    ; high volume data processing systems in clojure
                    ; you may want to explore them later

                    ; tranducers
                    ; core.async
                    ```
                </section-->

                <section data-markdown>
                    ```clj
                    ; open the file divisors_test.clj
                    ; and make the test cases pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; this is my solution
                    (fn [n]
                      (filter #(zero? (rem n %)) 
                        (range 1 n))) 
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; write a function that checks if a number is a 
                    ; perfect number or not
                    ; a perfect number is one which is equal to
                    ; the sum of it's divisors

                    (= (__ 6) true)

                    (= (__ 7) false)

                    (= (__ 496) true)

                    (= (__ 500) false)

                    (= (__ 8128) true)
                    ```
                </section>

                <section>
                    <h2>Macros</h2>
                    <h3>Code that writes code</h3>
				        </section>

                <section data-markdown>
                    ```clj
                    ; in programming languages like java or c
                    ; the compiler translates your program text
                    ; into an intermediate form called the AST but
                    ; this AST is not accessible to you, the programmer

                    ; in clojure and other lisps the textual representation
                    ; of your code is coverted to a list data structure which
                    ; is the AST
                    ; hence, in clojure all your code is data
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list + 1 2))
                    ;=> 3

                    ; note that eval works on a list data structure
                    ; not a textual representation of it.

                    (eval (concat (list + 1 2) [10]))
                    ;=> 13
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    ; code generators in other languages generate text,
                    ; but manipulating data is more powerful than manipulating
                    ; text

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; macros are code that return lists to be evaluated
                    ; by the clojure interpreter
                    (defmacro infix
                    [[left-operand operator right-operand]]
                    (list operator left-operand right-operand))

                    (infix (2 + 3))

                    ; the arguments to a macro are not evaluated.
                    ; try writing infix as a normal function
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create lists in macros using list
                    ; but there's another way.
                    ; the syntax quote
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    (macroexpand-1
                    (list 'def 'lucky-number (concat (list '+ 1 2) [10])))
                    ;=> (def lucky-number (+ 1 2 10))

                    (macroexpand-1 `(def lucky-number ~(concat '(+ 1 2) [10])))
                    ;=> (def user/lucky-number (+ 1 2 10))

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; if you want to see how our infix macro looks like
                    ; syntax quote, here it is
                    (defmacro infix
                    [[left-operand operator right-operand]]
                    `(~operator ~left-operand ~right-operand))

                    (infix (2 + 3))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; another macro
                    (defmacro on-debug
                    [& body]
                    `(when DEBUG (do ~@body)))

                    (def DEBUG false)

                    (on-debug (println "hello"))
                    ;=> nil

                    (macroexpand-1 '(on-debug (println "hello")))
                    ;=> (clojure.core/when user/DEBUG (do (println "hello")))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; that seems vaguely cool, but why should you care ?
                    ; macros let the programmer extend the langauge to
                    ; fit your problem domain.

                    ; even clojure defines lots of essential functionality
                    ; as macros - and, or, when
                    ```
                </section>

                <!-- section>
                    <h3>Organizing your project</h3>
                    <p>Leiningen is the most prevalent build tool for clojure</p>
                    <p>Boot is another one gaining in popularity</p>
                    <p>We will focus on leiningen for now</p>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; to create a new project we can run the following

                    lein new app my-app

                    ; this will create a directory structure that looks like

                    <pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">|</span> <span class="tok-nv">.gitignore</span>
                        <span class="tok-err">|</span> <span class="tok-nv">doc</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">intro.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">project.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">README.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">resources</span>
                        <span class="tok-err">|</span> <span class="tok-nv">src</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">test</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core_test.clj</span>
                    </code></pre>
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's take a look at some of the important pieces there

                    ; note that the hyphens in your project name are changed to 
                    ; underscores in the directory and file names

                    ; project.clj holds the configuration and dependencies

                    ; core.clj is a dummy starting point for your project

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; some useful commands are

                    lein deps

                    lein compile

                    lein run

                    lein repl

                    lein uberjar
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; write a function that returns intersection of two sets
                    ; i.e. items common to both sets

                    (= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})

                    (= (__ #{0 1 2} #{3 4 5}) #{})

                    (= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; here's one solution

                    #(set (filter  %1 %2))
                    ```
                </section-->

                <section>
                    <h3>Java interop</h3>
                    <ul>
                        <li>Clojure has seamless access to java libraries since it runs on the JVM</li>
                        <li>This allows clojure to use the extensive Java eco-system of libraries</li>
                    </ul>
                </section>

                <section data-markdown>
                    ```clj
                    ; we can call methods on an object using the
                    ; (.methodName object) notation

                    ; since clojure strings are implemented as
                    ; java strings it allows us to do this

                    (.toUpperCase "hello world")
                    ;=> "HELLO WORLD"

                    (.indexOf (.toUpperCase "hello world") "W")
                    ;=> 6
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; and we can use the threading macro for jave interop
                    ; to apply multiple methods

                    (.. "hello world"
                      toUpperCase 
                      (indexOf "W"))
                    ;=> 6
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can call static methods of classes or
                    ; access static fields as follows

                    (java.lang.Math/abs -3)
                    ;=> 3

                    java.lang.Math/PI
                    ;=> 3.141592653589793
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create new objects in two ways

                    (new String)
                    ;=> ""

                    (String.)
                    ;=> ""

                    (String. "hello world")
                    ;=> "hello world"
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create new objects in two ways
                    (let [s (String. "hello world")]
                      (.. s
                        toUpperCase
                        (indexOf "W")))
                    ```
                </section>

                

                <section>
                    <h2>Resources</h2>
                    <ul>
                        <li>https://clojuredocs.org/</li>
                        <li>http://www.4clojure.com/</li>
                        <li>http://www.braveclojure.com/clojure-for-the-brave-and-true/</li>
                    </ul>
	              </section>

                <section>
	                  <h3>End Note</h3>
	                  <blockquote>
	                      A language that doesn't affect the way you think about programming, is not worth knowing.<br>â€”Alan Perlis
	                  </blockquote>
	              </section>

            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>

         // Full list of configuration options available at:
         // https://github.com/hakimel/reveal.js#configuration
         Reveal.initialize({
             controls: true,
             progress: true,
             history: true,
             center: true,

             transition: 'slide', // none/fade/slide/convex/concave/zoom

             math: {
					       mathjax: 'reveal.js/plugin/math/MathJax/MathJax.js',
					       config: 'TeX-AMS_CHTML-full'
				     },
             // Optional reveal.js plugins
             dependencies: [
                 { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                 { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                 { src: 'reveal.js/plugin/notes/notes.js', async: true },
                 { src: 'reveal.js/plugin/math/math.js', async: true },
                 { src: 'reveal.js/plugin/reveal-sampler-master/sampler.js' }
             ]
         });

        </script>

    </body>

</html>
