<!doctype html>
<html lang="en">

	  <head>
		    <meta charset="utf-8">

		    <title>Clojure - made with secret alien technology</title>

		    <meta name="description" content="Slides for the functional thinking with clojure training">
		    <meta name="author" content="Anuj Seth">

		    <meta name="apple-mobile-web-app-capable" content="yes">
		    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		    <link rel="stylesheet" href="reveal.js/css/reveal.css">
		    <link rel="stylesheet" href="reveal.js/css/theme/black.css" id="theme">
		    <!-- link rel="stylesheet" href="custom.css"-->

		    <!-- Code syntax highlighting -->
		    <link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		    <!-- Printing and PDF exports -->
		    <!-- script>
			   var link = document.createElement( 'link' );
			   link.rel = 'stylesheet';
			   link.type = 'text/css';
			   link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			   document.getElementsByTagName( 'head' )[0].appendChild( link );
		    </script-->

		    <!--[if lt IE 9]>
		        <script src="lib/js/html5shiv.js"></script>
		    <![endif]-->
	  </head>

	  <body>

		    <div class="reveal">

			      <!-- Any section element inside of this container is displayed as a slide -->
			      <div class="slides">
				        <section>
					          <h1>Clojure</h1>
					          <p>
                        <img src="resources/images/alien_technology.png">
					              <br><small>Trainer <a>Anuj Seth</a> </small></br>
					          </p>
				        </section>

                <section>
                    <h2>Regular Expressions</h2>
				        </section>

                <section>
	                  <blockquote>
	                      Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.<br>â€” Jamie Zawinski
	                  </blockquote>
	              </section>

                <section>
                    <p>Strings with a hash in the front are regular expressions - #"regex"</p>
                    <p>Clojure regexes produce java.util.regex.Pattern objects</p>
                    <p>Clojure uses the same regex syntax as java.util.regex.Pattern</p>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; re-matches matches the whole string
                    (re-matches #"abc" "abcabc")
                    ;=> nil

                    (re-matches #"abc.*" "abcabc")
                    ;=> "abcabc"

                    ;; if the regex has groups then we get
                    ;; a vector whose first element is the full match
                    ;; and rest are the matching groups
                    (re-matches #"abc(.*)" "abcabc")
                    ;=> ["abcabc" "abc"]
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if the regex has groups then we get
                    ;; a vector whose first element is the full match
                    ;; and rest are the matching groups
                    (re-matches #"abc(\d+)\|(\w*)" "abc123|def")
                    ;=> ["abc123|def" "123" "def"]

                    ;; re-matches can return three types of values
                    ;; nil, a string or a vector
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; let's make some test cases pass
                    ;; open the file regex_test.clj
                    ;; and make the first test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; re-find returns the first match within a string
                    (re-find #"\d{3}" "abc123abc456")
                    ;=> "123"

                    ;; with groups we get a vector
                    ;; just like re-matches
                    ;; you can match exact number of characters
                    ;; with {n}
                    ;; at least n not more than m with {n,m}
                    (re-find #"(\d{3})\w+(\d{3})" "abc123abc456")
                    ;=> ["123abc456" "123" "456"]
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file regex_test.clj
                    ;; and make the second test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; re-seq can be used to get all the matches
                    (re-seq #"\d" "abc123abc456")
                    ;=> ("1" "2" "3" "4" "5" "6")

                    ;; open the file regex_test.clj
                    ;; and make the third test case pass
                    ```
                </section>

                <section>
                    <pre><code data-trim>
                    ;; replace can be used to replace patterns in a string
                    (clojure.string/replace "John, Paul, George, Stuart"
                                            #"Stuart"
                                            "Ringo")
                    ;=> "John, Paul, George, Ringo"

                    ;; we can replace groups
                    (clojure.string/replace "+919887652314"
                                            #"(^\+)"
                                            "00")
                    ;=> "00919887652314"
                    </code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; we can give a function that provides the replacement
                    ;; let's see how that works in the next test case
                    ;; in regex_test.clj
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; we can split strings on a regex
                    (clojure.string/split "+91-9876-65438" #"-")
                    ;=> ["+91" "9876" "65438"]
                    ```
                </section>

				        <section>
                    <h2>Exceptions</h2>
				        </section>

                <section>
                    <pre><code data-trim>
                    (try
                        (/ 1 0)
                        (catch Exception e (str "caught exception: "
                                                (.getMessage e))))
                    ;=> "caught exception: Divide by zero"
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim>
                    ;; the accepted wisdom these days is to use ex-info
                    (try
                        (throw (ex-info "thrown exception: "
                                        {:msg "this is an exception"}))
                        (catch Exception e (ex-data e)))
                    ;=> {:msg "this is an exception"}

                    ;; you can print the ex-info object to get the
                    ;; full stack trace
                    </code></pre>
                </section>

                <section>
                    <pre><code data-trim>
                    ;; the message can be retrieved like this
                    (try
                        (throw (ex-info "thrown exception: "
                                        {:msg "this is an exception"}))
                        (catch Exception e (.getMessage e)))
                    ;=> "thrown exception: "

                    ;; the message is added to satisfy the base Throwable
                    ;; that has a detailMessage field in it
                    </code></pre>
                </section>

                <section>
                    <h2>Exceptions</h2>
                    <p>Don't use them</p>
                    <p>What follows is my opinion</p>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; open the file error_handling_test.clj
                    ;; to see what I mean

                    ;; and of course make the test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; a concern that you may have in the previous example:
                    ;; ok-or-never gets called even after one of the functions
                    ;; returns :error

                    ;; reduced to the rescue
                    ;; a slightly convoluted example
                    (reduce (fn [acc idx]
                              (if (= idx 26)
                                (reduced acc)
                                (assoc acc
                                       (char (+ 65 idx)) 
                                       (inc idx))))
                            {}
                            (range))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file error_handling_test_short_circuit.clj
                    ;; to see if you can use reduced

                    ;; and of course make the test case pass
                    ```
                </section>

				        <section>
                    <h2>Polymorphism and Types</h2>
				        </section>

				        <section>
                    <h2>Multimethods</h2>
				        </section>

                <section>
                    <p>Clojure supports runtime polymorphism through multimethods</p>
                    <p>Multimethods provide dispatch on an arbitrary function</p>
                    <p>Contrast this with OO polymorphism which dispatches on type of one variable</p>
				        </section>

                <section data-markdown>
                    ```clj
                    (defmulti data-handler :status)
                    (defmethod data-handler :error
                      [m]
                      (println "we have an error"))
                    (defmethod data-handler :ok
                      [m]
                      (println "we have good data"))
                    (defmethod data-handler :default
                      [m]
                      (println "we don't know what we have"))

                    (data-handler {:status :error})
                    ;=> we have an error
                    (data-handler {})
                    ;=> we don't know what we have
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file tree_walk_test.clj
                    ;; write a multimethod to evaluate the tree nodes
                    ;; and make the test case pass
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; did you notice that all our binary operators
                    ;; had the same code.

                    ;; hierarchies allow us to define relationships
                    ;; most commonly between keywords
                    (derive ::superman ::superhero)
                    (derive ::wonder-woman ::superhero)
                    (derive ::lex-luthor ::supervillain)

                    ;; what do the :: tell you ?
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; isa? can be used to query the hierarchy

                    (isa? ::superman ::superhero)
                    ;=> true
                    (isa? ::superman ::supervillain)
                    ;=> false
                    (isa? ::lex-luthor ::supervillain)
                    ;=> true
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (defmulti evil? :name)

                    (defmethod evil? ::superhero [_] :never)

                    (defmethod evil? ::lex-luthor [_] :always)

                    (evil? {:name ::superman})
                    ;; :never
                    (evil? {:name ::lex-luthor})
                    ;; :always
                    ```
	              </section>

                <section data-markdown>
                    ```clj
                    (derive ::batman ::superhero)
                    (defmethod evil? ::batman [_] :only-when-ends-justify-means)

                    (evil? {:name ::batman})
                    ```
	              </section>

                <section data-markdown>
                    ```clj
                    ;; open the file hierarchical_tree_walk_test.clj
                    ;; complete the multimethod definition
                    ;; and make the test case pass
                    ```
                </section>

                <section>
                    <h2>Protocols and Types</h2>
				        </section>

                <section>
                    <p>Protocols allow polymorphism on the type of the first argument</p>
                    <p>They are very fast</p>
                    <p>Don't worry if you have never used them</p>
				        </section>

                <section>
                    <p>Protocols provide a solution to the expression problem</p>
                    <p>What is the expression problem ?</p>
                    <p>Extend preexisting types to new methods</p>
                    <p>Extend preexisting methods to new types</p>
                    <p>Without touching existing code</p>
                </section>

                <section>
                    <font size="6">
                    <ul>
                        <li>OO makes it easy for new types to extend existing interfaces</li>
                        <ul>
                            <li>ArrayList, LinkedList, Stack all implement same interface</li>
                            <li>You can add a new type easily</li>
                        </ul>
                        <li>Functional languages make it easy to add functions over existing types</li>
                        <ul>
                            <li>conj, nth, count work with list, vector, map</li>
                            <li>You can add new functions supporting all types</li>
                        </ul>
                    </ul>
                    </font>
                </section>

                <section data-markdown>
                    ```clj
                    ;; what are protocols ?
                    ;; we want to encrypt our data
                    (defprotocol Encryptable
                      (encrypt [this] "Encrypt the given object"))

                    (extend-type java.lang.String
                      Encryptable
                      (encrypt [this] (apply str (reverse this))))

                    (encrypt "a string")
                    ;;=> "gnirts a"
                    ;; how about extending a hash map to be Encryptable ?
                    ;; Encrypt by converting to a string and encrypting that.
                    ;; what is the type of a hash-map ?
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (extend-type clojure.lang.PersistentArrayMap
                      Encryptable
                      (encrypt [this] (encrypt (str this))))

                    (encrypt {})
                    ;;=> "}{"
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if you want to provide implementations of
                    ;; multiple types at the same time
                    (extend-protocol Encryptable
                      java.lang.String
                      (encrypt [this] (apply str (reverse this)))
                      clojure.lang.PersistentArrayMap
                      (encrypt [this] (encrypt (str this))))
                    ```
                </section>

				        <section>
                    <h2>Records</h2>
				        </section>

                <section data-markdown>
                    ```clj
                    ;; records are structured data types
                    ;; and along with deftype provide a way to
                    ;; implement abstractions defined by protocols
                    (defrecord Airport [icao iata])

                    ;; they come with 2 factory functions
                    (->Airport "ZBAA" "PEK")

                    (map->Airport {:icao "ZBAA"
                                   :iata "PEK"})
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; and for most purposes act like maps
                    (:iata (map->Airport {:icao "ZBAA"}))

                    (:icao (map->Airport {:icao "ZBAA"}))

                    ;; except that you cannot use them in the
                    ;; function place
                    ;; but we will fix that soon for our records
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ;; if you dissoc a field what happens.
                    (dissoc (->Airport "ZBAA" "PEK") :icao)
                    ;; is it still an Airport ?

                    ;; you can also assoc extra keys to it
                    (assoc (->Airport "ZBAA" "PEK") :city "Beijing")
                    ;; is it still an Airport ?
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#place-protocol'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; can you create a record called City
                    ;; with 2 fields - name and country
                    ;; implementing the Place protocol
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#city'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#usage'></code></pre>
                </section>


                <section data-markdown>
                    ```clj
                    ;; let's say six months from now I have the
                    ;; requirement to add a function - is-in
                    ;; that reports the location of the place.
                    ;; we could modify the original Place protocol
                    ;; or extend our types to implement a new protocol
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#is-in'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#is-in-usage'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; how can I make my Airport record a callable function ?
                    ;; implement the clojure.lang.IFn interface methods
                    ;; (invoke [this k] ....)
                    ;; (invoke [this k not-found] ....)

                    ;; for completeness we should also implement applyTo
                    ;; or maybe not
                    ;; did anyone ever use apply with a hash map ?
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#callable-records-short'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/records.clj#callable-records'></code></pre>
                </section>

                <section>
                    <h2>Types</h2>
				        </section>

                <section>
                    <pre><code data-sample='files/types.clj#types'></code></pre>
                </section>

                <section>
	                  <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Concurrency and parallelism are two related but different things</li>
                        <li>Concurrency is managing multiple tasks</li>
                        <li>Concurrency might be implemented by switching between multiple tasks running on one processor</li>
                        <li>Parallelism is a subset of concurrency and entails executing multiple tasks at the same time</li>
                    </ul>
                </section>


                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pvalues'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pvalues-time'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pvalues-time-explanation'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pmap'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pmap-experiment'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pmap-time'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pmap-time-explanation'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/concurrency_parallelism.clj#pcalls'></code></pre>
                </section>

                <section>
	                  <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Futures</li>
                        <li>Delays</li>
                        <li>Promises</li>
                    </ul>
                </section>


                <section>
	                  <h3>Concurrency and Parallelism</h3>
                    <p>Futures, delays and promises allow us to write concurrent code by decoupling</p>
                    <ul>
                        <li>Task definition</li>
                        <li>Task execution</li>
                        <li>Requiring the task's result</li>
                    </ul>
                </section>

                <section>
                    <h3>Concurrency and Parallelism</h3>
                    <ul>
                        <li>Our serial code consists of task definitions like <br>(web-api/get-customer 1234)</br></li>
                        <li>As soon as clojure encouters this it executes the task and blocks until the result of the API is available</li>
                        <li>Now let's see how futures, delays and promises let us break this flow</li>
                    </ul>
                </section>


                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#futures'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#futures-result'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#futures-realized'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file futures_test.clj
                    ;; and make the test cases pass

                    ;; how will you wait for a sequence of
                    ;; futures ?
                    ;; (map deref s)

                    ;; beware of laziness

                    ```
                </section>

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#delays'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#delay-example'></code></pre>
                </section>

                <!-- section>
                     <pre><code data-sample='files/futures_delays_promises.clj#delay-closure'></code></pre>
                     </section-->

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#promises'></code></pre>
                </section>

                <!--section>
                     <pre><code data-sample='files/futures_delays_promises.clj#promise-example'></code></pre>
                     </section-->

                <section>
                    <pre><code data-sample='files/futures_delays_promises.clj#promise-example-2'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file promised_data_pipeline_test.clj
                    ;; and make the test case pass.
                    ```
                </section>

                <section>
                    <h3>Concurrency and State</h3>
                    <ul>
                        <li>Java and other imperative languages manage shared state concurrency by using locks</li>
                        <li>These locks and mutexes protect access to shared data</li>
                        <li>Let's talk about how Clojure manages mutating state and concurrency</li>
                        <li>But I said clojure has immutable data structures !!!</li>
                    </ul>
                </section>


                <section>
                    <h3>Concurrency and State</h3>
                    <p>We will take a look at the following clojure reference types</p>
                    <ul>
                        <li>Atoms</li>
                        <li>Refs</li>
                        <li>Agents</li>
                    </ul>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#atoms'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#atom-ops'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#atom-ops-2'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; what happens if two threads call swap! on the same
                    ; atom ? can we lose one of those updates ?
                    ; the answer is no since atoms follow compare and set
                    ; semantics.
                    ; what this means is that atoms
                    ; 1. read current state of the atom
                    ; 2. apply update function
                    ; 3. recheck that atom's current value is same as step 1
                    ; 4. if yes, then update atom to new state
                    ; 5. else go through the process again
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#atom-tests'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#atom-tests-solution'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#refs'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#refs-2'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ; transactions on refs support the ACI properties, 
                    ; subset of ACID in databases

                    ; they are atomic - all refs are updated or none
                    ; they are consistent- refs will always have valid states
                    ; they are isolated - transactions are executed serially

                    ; if two threads run simultaneous transactions, 
                    ; one of them will retry 
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#ref-set'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file ref_test.clj
                    ;; and make the test cases pass
                    ```
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#agents'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/atoms_refs_agents.clj#agent-send-off'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file log_agent.clj
                    ; and fill in the blanks
                    ```
                </section>

                <section>
                    <h3>core.async</h3>
                    <ul>
                        <li>Based on Tony Hoare's CSP work</li>
                        <li>And the work done in Go, occam, etc</li>
                        <li>Provides queues or channels between independent threads</li>
                        <li>Avoids callback hell</li>
                        <li>Is implemented as a library</li>
                    </ul>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#channels'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#channels-2'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#thread'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#go'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#park-vs-block'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#go-2'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#go-loop'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#go-vs-thread'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/core_async.clj#go-pipeline'></code></pre>
                </section>

                <section data-markdown>
                    ```clj
                    ;; open the file channel_pipeline_test.clj
                    ;; implement the stage function and make the test
                    ;; case pass
                    ```
                </section>

                <section>
                    <h3>Transducers</h3>
                    <ul>
                        <li>Define transformations without tying them to inputs or outputs</li>
                        <li>Efficient since they do not create intermediate sequences</li>
                        <li>Lead to cleaner design by seperate transformation from application</li>
                        <li>Most core sequence functions have a single arity version returning a transducer</li>
                    </ul>
                </section>

                <section>
                    <pre><code data-sample='files/transducers.clj#intro'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/transducers.clj#intro-2'></code></pre>
                </section>

                <section>
                    <pre><code data-sample='files/transducers.clj#comp'></code></pre>
                </section>


                <!-- section data-markdown>
                    ```clj
                    ; there are other ways of getting concurrency or writing
                    ; high volume data processing systems in clojure
                    ; you may want to explore them later

                    ; tranducers
                    ; core.async
                    ```
                </section-->


                <section data-markdown>
                    ```clj
                    ; this is my solution
                    (fn [n]
                      (filter #(zero? (rem n %)) 
                        (range 1 n))) 
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; write a function that checks if a number is a 
                    ; perfect number or not
                    ; a perfect number is one which is equal to
                    ; the sum of it's divisors

                    (= (__ 6) true)

                    (= (__ 7) false)

                    (= (__ 496) true)

                    (= (__ 500) false)

                    (= (__ 8128) true)
                    ```
                </section>

                <section>
                    <h2>Macros</h2>
                    <h3>Code that writes code</h3>
				        </section>

                <section data-markdown>
                    ```clj
                    ; in programming languages like java or c
                    ; the compiler translates your program text
                    ; into an intermediate form called the AST but
                    ; this AST is not accessible to you, the programmer

                    ; in clojure and other lisps the textual representation
                    ; of your code is coverted to a list data structure which
                    ; is the AST
                    ; hence, in clojure all your code is data
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list + 1 2))
                    ;=> 3

                    ; note that eval works on a list data structure
                    ; not a textual representation of it.

                    (eval (concat (list + 1 2) [10]))
                    ;=> 13
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    ; code generators in other languages generate text,
                    ; but manipulating data is more powerful than manipulating
                    ; text

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; macros are code that return lists to be evaluated
                    ; by the clojure interpreter
                    (defmacro infix
                    [[left-operand operator right-operand]]
                    (list operator left-operand right-operand))

                    (infix (2 + 3))

                    ; the arguments to a macro are not evaluated.
                    ; try writing infix as a normal function
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create lists in macros using list
                    ; but there's another way.
                    ; the syntax quote
                    (eval (list 'def 'lucky-number (concat (list + 1 2) [10])))
                    ;=> #'user/lucky-number
                    lucky-number
                    ;=> 13

                    (macroexpand-1
                    (list 'def 'lucky-number (concat (list '+ 1 2) [10])))
                    ;=> (def lucky-number (+ 1 2 10))

                    (macroexpand-1 `(def lucky-number ~(concat '(+ 1 2) [10])))
                    ;=> (def user/lucky-number (+ 1 2 10))

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; if you want to see how our infix macro looks like
                    ; syntax quote, here it is
                    (defmacro infix
                    [[left-operand operator right-operand]]
                    `(~operator ~left-operand ~right-operand))

                    (infix (2 + 3))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; another macro
                    (defmacro on-debug
                    [& body]
                    `(when DEBUG (do ~@body)))

                    (def DEBUG false)

                    (on-debug (println "hello"))
                    ;=> nil

                    (macroexpand-1 '(on-debug (println "hello")))
                    ;=> (clojure.core/when user/DEBUG (do (println "hello")))
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; that seems vaguely cool, but why should you care ?
                    ; macros let the programmer extend the langauge to
                    ; fit your problem domain.

                    ; even clojure defines lots of essential functionality
                    ; as macros - and, or, when
                    ```
                </section>

                <!-- section>
                    <h3>Organizing your project</h3>
                    <p>Leiningen is the most prevalent build tool for clojure</p>
                    <p>Boot is another one gaining in popularity</p>
                    <p>We will focus on leiningen for now</p>
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; to create a new project we can run the following

                    lein new app my-app

                    ; this will create a directory structure that looks like

                    <pre class="pygments highlight"><code data-lang="clojure" class="block"><span class="tok-err">|</span> <span class="tok-nv">.gitignore</span>
                        <span class="tok-err">|</span> <span class="tok-nv">doc</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">intro.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">project.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">README.md</span>
                        <span class="tok-err">|</span> <span class="tok-nv">resources</span>
                        <span class="tok-err">|</span> <span class="tok-nv">src</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core.clj</span>
                        <span class="tok-err">|</span> <span class="tok-nv">test</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">my_app</span>
                        <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-err">|</span> <span class="tok-nv">core_test.clj</span>
                    </code></pre>
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; let's take a look at some of the important pieces there

                    ; note that the hyphens in your project name are changed to 
                    ; underscores in the directory and file names

                    ; project.clj holds the configuration and dependencies

                    ; core.clj is a dummy starting point for your project

                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; some useful commands are

                    lein deps

                    lein compile

                    lein run

                    lein repl

                    lein uberjar
                    ```
                </section-->

                <!-- section data-markdown>
                    ```clj
                    ; write a function that returns intersection of two sets
                    ; i.e. items common to both sets

                    (= (__ #{0 1 2 3} #{2 3 4 5}) #{2 3})

                    (= (__ #{0 1 2} #{3 4 5}) #{})

                    (= (__ #{:a :b :c :d} #{:c :e :a :f :d}) #{:a :c :d})

                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; here's one solution

                    #(set (filter  %1 %2))
                    ```
                </section-->

                <section>
                    <h3>Java interop</h3>
                    <ul>
                        <li>Clojure has seamless access to java libraries since it runs on the JVM</li>
                        <li>This allows clojure to use the extensive Java eco-system of libraries</li>
                    </ul>
                </section>

                <section data-markdown>
                    ```clj
                    ; we can call methods on an object using the
                    ; (.methodName object) notation

                    ; since clojure strings are implemented as
                    ; java strings it allows us to do this

                    (.toUpperCase "hello world")
                    ;=> "HELLO WORLD"

                    (.indexOf (.toUpperCase "hello world") "W")
                    ;=> 6
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; and we can use the threading macro for jave interop
                    ; to apply multiple methods

                    (.. "hello world"
                      toUpperCase 
                      (indexOf "W"))
                    ;=> 6
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can call static methods of classes or
                    ; access static fields as follows

                    (java.lang.Math/abs -3)
                    ;=> 3

                    java.lang.Math/PI
                    ;=> 3.141592653589793
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create new objects in two ways

                    (new String)
                    ;=> ""

                    (String.)
                    ;=> ""

                    (String. "hello world")
                    ;=> "hello world"
                    ```
                </section>

                <section data-markdown>
                    ```clj
                    ; we can create new objects in two ways
                    (let [s (String. "hello world")]
                      (.. s
                        toUpperCase
                        (indexOf "W")))
                    ```
                </section>

                

                <section>
                    <h2>Resources</h2>
                    <ul>
                        <li>https://clojuredocs.org/</li>
                        <li>http://www.4clojure.com/</li>
                        <li>http://www.braveclojure.com/clojure-for-the-brave-and-true/</li>
                    </ul>
	              </section>

                <section>
	                  <h3>End Note</h3>
	                  <blockquote>
	                      A language that doesn't affect the way you think about programming, is not worth knowing.<br>â€”Alan Perlis
	                  </blockquote>
	              </section>

            </div>

        </div>

        <script src="reveal.js/lib/js/head.min.js"></script>
        <script src="reveal.js/js/reveal.js"></script>

        <script>

         // Full list of configuration options available at:
         // https://github.com/hakimel/reveal.js#configuration
         Reveal.initialize({
             controls: true,
             progress: true,
             history: true,
             center: true,

             transition: 'slide', // none/fade/slide/convex/concave/zoom

             math: {
					       mathjax: 'reveal.js/plugin/math/MathJax/MathJax.js',
					       config: 'TeX-AMS_CHTML-full'
				     },
             // Optional reveal.js plugins
             dependencies: [
                 { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                 { src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                 { src: 'reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                 { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
                 { src: 'reveal.js/plugin/notes/notes.js', async: true },
                 { src: 'reveal.js/plugin/math/math.js', async: true },
                 { src: 'reveal.js/plugin/reveal-sampler-master/sampler.js' }
             ]
         });

        </script>

    </body>

</html>
